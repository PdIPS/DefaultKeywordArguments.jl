var documenterSearchIndex = {"docs":
[{"location":"#DefaultKeywordArguments.jl","page":"Home","title":"DefaultKeywordArguments.jl","text":"<iframe src=\"https://ghbtns.com/github-btn.html?user=PdIPS&repo=DefaultKeywordArguments.jl&type=star&count=true&size=large\" frameborder=\"0\" scrolling=\"0\" width=\"170\" height=\"30\" title=\"GitHub\"></iframe>\n\nDefaultKeywordArguments.jl is a package to handle default keyword arguments in Julia. It has been developed to support CBX.jl.","category":"section"},{"location":"#The-@default-Macro","page":"Home","title":"The @default Macro","text":"In Julia, functions can have keyword arguments with a default value. The function\n\nwith_keywords(x; a = 2.0, b = 3.0, c = 4.0) = (a * x + b) / c;\n\nwill return (2.0 * x + 3.0) / 4.0 unless you specify a different value of a, b, or c.\n\nWhen you're writing a complex piece of software, you may have multiple functions that use the keyword arguments a, b, and c, and which should all use the same default value. For instance:\n\nwith_keywords(x; a = 2.0, b = 3.0, c = 4.0) = (a * x + b) / c;\nanother_with_keywords(x; a = 2.0, b = 3.0, c = 4.0) = round(Int, (a * x + b) / c);\nyet_another_with_keywords(x; a = 2.0, b = 3.0, c = 4.0) = round(Int, c / (a * x + b));\n\nIf you have many functions and many keyword arguments, maintaining consistency of the default values can soon become cumbersome. One sensible option would be to collect all the default values in a single place:\n\nconst default_values = (; a = 2.0, b = 3.0, c = 4.0);\nwith_keywords(x; a = default_values.a, b = default_values.b, c = default_values.c) = (a * x + b) / c;\nanother_with_keywords(x; a = default_values.a, b = default_values.b, c = default_values.c) = round(Int, (a * x + b) / c);\nyet_another_with_keywords(x; a = default_values.a, b = default_values.b, c = default_values.c) = round(Int, c / (a * x + b));\n\nHowever, writing a = default_values.a, b = default_values.b, and c = default_values.c over and over is tedious, and can clutter your code.\n\nThe @default macro offers an alternative:\n\nconst default_values = (; a = 2.0, b = 3.0, c = 4.0);\n@default default_values with_keywords(x; a, b, c) = (a * x + b) / c;\n@default default_values another_with_keywords(x; a, b, c) = round(Int, (a * x + b) / c);\n@default default_values yet_another_with_keywords(x; a, b, c) = round(Int, c / (a * x + b));\n\nYou can write non-compact functions instead:\n\nconst default_values = (; a = 2.0, b = 3.0, c = 4.0);\n@default default_values function with_keywords(x::Float64; a, b, c)\n  return (a * x + b) / c\nend\n\nYou can also write type annotations and default values as usual. Furthermore, you can overwrite the default values of each keyword argument individually, if required. These are all valid:\n\nconst default_values = (; a = 2.0, b = 3.0, c = 4.0);\n\n# x must be a Float64\n@default default_values with_keywords(x::Float64; a, b, c) = (a * x + b) / c;\n\n# x has a default value of 7\n@default default_values another_with_keywords(x = 7; a, b, c) = round(Int, (a * x + b) / c);\n\n# the default value of a is overriden to 17.5\n@default default_values yet_another_with_keywords(x; a = 17.5, b, c) = round(Int, c / (a * x + b));","category":"section"},{"location":"#The-@config-Macro","page":"Home","title":"The @config Macro","text":"You might require a more advanced version of parameter handling, where you just pass a config object which propagates across your functions, and then they selectively use default values for certain variables whenever they are not available in config:\n\nfunction first_call(config)\n  a = (haskey(config, :a)) ? config.a : 2.0\n  b = (haskey(config, :b)) ? config.b : 3.0\n  # some code\n  return second_call(config)\nend\n\nfunction second_call(config)\n  a = (haskey(config, :a)) ? config.a : 2.0\n  c = (haskey(config, :c)) ? config.c : 4.0\n  # some more code\nend\n\nCalling my_config = (; a = 1.0); first_call(my_config) would use your custom value of a in both functions, but use the default values of b and c when required.\n\nA way to maintain consistency of the default values would be to replace this with:\n\nconst default_config = (; a = 2.0, b = 3.0, c = 4.0);\n\nfunction first_call(config)\n  return first_call_expanded(config; config...)\nend\n\nfunction first_call_expanded(config; a = default_config.a, b = default_config.b, args...)\n  b = (haskey(config, :b)) ? config.b : 3.0\n  # some code\n  return second_call(config)\nend\n\nfunction second_call(config)\n  return second_call_expanded(config; config...)\nend\n\nfunction second_call_expanded(config; a = default_config.a, c = default_config.c, args...)\n  # some more code\nend\n\nThis code is verbose and repetitive. However, it can be generated by the @config macro instead:\n\nconst default_config = (; a = 2.0, b = 3.0, c = 4.0);\n\n@config default_config function first_call(; a, b)\n  # some code\n  return second_call(config)\nend\n\n@config default_config function second_call(; a, c)\n  # some more code\nend\n\nTo avoid repetition, you don't even have to specify the config argument on each function. Calling my_config = (; a = 1.0); first_call(my_config) will behave as in the previous code.\n\nOnce again, you are allowed to have extra arguments, type annotations, or default values, as you would in any other Julia function.\n\n:warning: The code pattern generated by @config allocates some heap memory. This macro should be used for high-level functions that are not performance-critical.","category":"section"},{"location":"#Function-Documentation","page":"Home","title":"Function Documentation","text":"\n\n(Image: Static Badge) (Image: Build Status) (Image: Coverage) (Image: Aqua) (Image: License: MIT)","category":"section"},{"location":"#DefaultKeywordArguments.@config-Tuple{Any, Any}","page":"Home","title":"DefaultKeywordArguments.@config","text":"@config default_config my_function(x; a, b) = ...\n\nThis macro creates a function my_function(config, x) which will have access to the variables a and b. The values a and b will be those in config, if they are present, or else those in default_config.\n\n\n\n\n\n","category":"macro"},{"location":"#DefaultKeywordArguments.@default-Tuple{Any, Any}","page":"Home","title":"DefaultKeywordArguments.@default","text":"@default default_values my_function(x; a, b) = ...\n\nThis macro assigns the values in default_values as the default values for the keyword arguments a and b.\n\n\n\n\n\n","category":"macro"}]
}
